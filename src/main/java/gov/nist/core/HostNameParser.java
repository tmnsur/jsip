package gov.nist.core;

import gov.nist.javax.sdp.parser.Lexer;

import java.text.ParseException;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Parser for host names.
 */
public class HostNameParser extends ParserCore {
	private static final Logger logger = Logger.getLogger(HostNameParser.class.getName());

	/**
	 * Determines whether or not we should tolerate and strip address scope
	 * zones from IPv6 addresses. Address scope zones are sometimes returned
	 * at the end of IPv6 addresses generated by InetAddress.getHostAddress().
	 * They are however not part of the SIP semantics so basically this method
	 * determines whether or not the parser should be stripping them (as
	 * opposed simply being blunt and throwing an exception).
	 */
	private static boolean stripAddressScopeZones = false;

	static {
		stripAddressScopeZones = Boolean.getBoolean("gov.nist.core.STRIP_ADDR_SCOPES");
	}

	public HostNameParser(String hname) {
		this.lexer = new LexerCore("charLexer", hname);
	}

	/**
	 * The lexer is initialized with the buffer.
	 */
	public HostNameParser(LexerCore lexer) {
		this.lexer = lexer;

		lexer.selectLexer("charLexer");
	}

	private static final char[] VALID_DOMAIN_LABEL_CHAR =
			// Add underscore as allowed character https://java.net/jira/browse/JSIP-506
			new char[] {LexerCore.ALPHADIGIT_VALID_CHARS, '-', '.', '_'};

	protected void consumeDomainLabel() {
		if(logger.isLoggable(Level.FINEST)) {
			debugEnter("domainLabel");
		}

		try {
			lexer.consumeValidChars(VALID_DOMAIN_LABEL_CHAR);
		} finally {
			if(logger.isLoggable(Level.FINEST)) {
				debugLeave("domainLabel");
			}
		}
	}

	protected String ipv6Reference() throws ParseException {
		StringBuilder retval = new StringBuilder();

		if(logger.isLoggable(Level.FINEST)) {
			debugEnter("ipv6Reference");
		}

		try {
			if(stripAddressScopeZones) {
				while(lexer.hasMoreChars()) {
					char la = lexer.lookAhead(0);

					//'%' is ipv6 address scope zone. see detail at
					//java.sun.com/j2se/1.5.0/docs/api/java/net/Inet6Address.html

					if(LexerCore.isHexDigit(la) || la == '.' || la == ':' || la == '[' ) {
						lexer.consume(1);
						retval.append(la);
					} else if (la == ']') {
						lexer.consume(1);
						retval.append(la);

						return retval.toString();
					} else if (la == '%'){
						//we need to strip the address scope zone.
						lexer.consume(1);

						String rest = lexer.getRest();

						if(rest == null || rest.length() == 0){
							//head for the parse exception
							break;
						}

						//we strip everything until either the end of the string
						//or a closing square bracket (])
						int stripLen = rest.indexOf(']');

						if(stripLen == -1){
							//no square bracket -> not a valid ipv6 reference
							break;
						}

						lexer.consume(stripLen+1);
						retval.append("]");

						return retval.toString();
					} else {
						break;
					}
				}
			} else {
				while(lexer.hasMoreChars()) {
					char la = lexer.lookAhead(0);
					if(LexerCore.isHexDigit(la) || la == '.' || la == ':' || la == '[') {
						lexer.consume(1);
						retval.append(la);
					} else if(la == ']') {
						lexer.consume(1);
						retval.append(la);

						return retval.toString();
					} else {
						break;
					}
				}
			}

			throw new ParseException(lexer.getBuffer() + ": Illegal Host name ", lexer.getPtr());
		} finally {
			if(logger.isLoggable(Level.FINEST)) {
				debugLeave("ipv6Reference");
			}
		}
	}

	public Host host() throws ParseException {
		if(logger.isLoggable(Level.FINEST)) {
			debugEnter("host");
		}

		try {
			String hostname;

			// IPv6 referene
			if(lexer.lookAhead(0) == '[') {
				hostname = ipv6Reference();
			} else if(isIPv6Address(lexer.getRest())) { // IPv6 address (i.e. missing square brackets)
				int startPtr = lexer.getPtr();
				lexer.consumeValidChars(new char[] {LexerCore.ALPHADIGIT_VALID_CHARS, ':'});
				hostname = new StringBuilder("[").append(lexer.getBuffer().substring(startPtr, lexer.getPtr()))
						.append("]").toString();
			} else { // IPv4 address or hostname
				int startPtr = lexer.getPtr();
				consumeDomainLabel();
				hostname = lexer.getBuffer().substring(startPtr, lexer.getPtr());
			}

			if(hostname.length() == 0) {
				throw new ParseException(lexer.getBuffer() + ": Missing host name", lexer.getPtr());
			}

			return new Host(hostname);
		} finally {
			if(logger.isLoggable(Level.FINEST)) {
				debugLeave("host");
			}
		}
	}

	/**
	 * Tries to determine whether the address in <tt>uriHeader</tt> could be
	 * an IPv6 address by counting the number of colons that appear in it.
	 *
	 * @param uriHeader the string (supposedly the value of a URI header) that
	 * we have received for parsing.
	 *
	 * @return true if the host part of <tt>uriHeader</tt> could be an IPv6
	 * address (i.e. contains at least two colons) and false otherwise.
	 */
	private boolean isIPv6Address(String uriHeader) {
		// Issue 275 https://jain-sip.dev.java.net/issues/show_bug.cgi?id=275 
		// we check if the uriHeader includes a comma, if that's the case we are potentially parsing
		// a multi header so strip everything after it
		String hostName = uriHeader;
		int indexOfComma = uriHeader.indexOf(",");
		if(indexOfComma != -1) {
			hostName  = uriHeader.substring(0, indexOfComma);
		}

		// approximately detect the end the host part.
		//first check if we have an uri param
		int hostEnd = hostName.indexOf(Lexer.QUESTION);

		//if not or if it appears after a semi-colon then the end of the
		//address would be a header param.
		int semiColonIndex = hostName.indexOf(Lexer.SEMICOLON);
		if(hostEnd == -1 || (semiColonIndex!= -1 && hostEnd > semiColonIndex)) {
			hostEnd = semiColonIndex;
		}

		// if there was no header param either the address
		//continues until the end of the string
		if(hostEnd == -1) {
			hostEnd = hostName.length();
		}

		//extract the address
		String host = hostName.substring(0, hostEnd);

		int firstColonIndex = host.indexOf(Lexer.COLON);

		if(firstColonIndex == -1) {
			return false;
		}

		int secondColonIndex = host.indexOf(Lexer.COLON, firstColonIndex + 1);

		return secondColonIndex != -1;
	}

	/**
	 * Parses a host:port string
	 *
	 * @param allowWS - whether whitespace is allowed around ':', only true for Via headers
	 * @return
	 * @throws ParseException
	 */
	public HostPort hostPort( boolean allowWS ) throws ParseException {
		if(logger.isLoggable(Level.FINEST)) {
			debugEnter("hostPort");
		}

		try {
			Host host = this.host();
			HostPort hp = new HostPort();

			hp.setHost(host);

			// Has a port?
			if(allowWS) {
				// white space before ":port" should be accepted
				lexer.SPorHT(); 
			}

			if(lexer.hasMoreChars()) {
				char la = lexer.lookAhead(0);
				switch (la) {
				case ':':
					lexer.consume(1);
					if(allowWS) {
						// white space before port number should be accepted
						lexer.SPorHT(); 
					}

					try {
						hp.setPort(Integer.parseInt(lexer.number()));
					} catch (NumberFormatException nfe) {
						throw new ParseException(lexer.getBuffer() + " :Error parsing port ", lexer.getPtr());
					}

					break;
				case ',':
					// allowed in case of multi-headers, e.g. Route
					// Could check that current header is a multi hdr
				case ';':
					// OK, can appear in URIs (parameters)
				case '?':
					// same, header parameters
				case '>':
					// OK, can appear in headers
				case ' ':
					// OK, allow whitespace
				case '\t':
				case '\r':
				case '\n':
				case '/':
					// e.g. http://[::1]/xyz.html
					break;
				case '%':
					if(stripAddressScopeZones){
						//OK,allow IPv6 address scope zone
						break;
					}
				default:
					if(!allowWS) {
						throw new ParseException(lexer.getBuffer() + " Illegal character in hostname:"
								+ lexer.lookAhead(0), lexer.getPtr() );
					}
				}
			}

			return hp;
		} finally {
			if(logger.isLoggable(Level.FINEST)) {
				debugLeave("hostPort");
			}
		}
	}
}
